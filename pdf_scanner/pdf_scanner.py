import sys
from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QFileDialog, QMessageBox,QLabel
import joblib
import fitz
import re
import os
import re
import sys
from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QFileDialog, QMessageBox, QLabel
from PyQt5.QtGui import QPixmap
import joblib
import fitz
from fitz import mupdf

from pdfminer.high_level import extract_text
from pdfminer.pdfparser import PDFSyntaxError
from pdfminer.pdfparser import PDFParser
from pdfminer.pdfdocument import PDFDocument
import PyPDF2
import fitz
from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter
from pdfminer.converter import TextConverter
from pdfminer.layout import LAParams
from pdfminer.pdftypes import resolve1
from io import StringIO
from pdfminer.high_level import extract_text
from pdfminer.pdfparser import PDFParser
from pdfminer.pdfdocument import PDFDocument
from pdfminer.pdfinterp import PDFResourceManager, PDFPageInterpreter
from pdfminer.converter import TextConverter
from pdfminer.layout import LAParams
from pdfminer.pdftypes import resolve1
from io import StringIO

import warnings
warnings.filterwarnings("ignore")


class PDFClassifierApp(QWidget):
    def __init__(self):
        super().__init__()

        self.initUI()

    def initUI(self):
        self.setFixedSize(600, 400)
        self.setWindowTitle('PDF Classifier')

        # Background image
        background_label = QLabel(self)
        pixmap = QPixmap(r"wallpaper.jpg")  # Replace with the path to your image
        background_label.setPixmap(pixmap)
        background_label.resize(self.size())

        # Select PDF button
        self.btnSelectFile = QPushButton('Select PDF File', self)
        self.btnSelectFile.setGeometry(100, 250, 200, 50)  # Adjust position and size as needed
        self.btnSelectFile.clicked.connect(self.selectFile)

        self.show()


    def selectFile(self):
        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        filePath, _ = QFileDialog.getOpenFileName(self, "Select PDF File", "", "PDF Files (*.pdf);;All Files (*)", options=options)
        # print(filePath, "\n\n\n")
        if filePath:
            result = self.predictPDF(filePath)
            QMessageBox.information(self, 'Prediction Result', result)

    def predictPDF(self,pdf_file_path):
        # Feature extraction and prediction code
        try:
            # Your existing feature extraction code here
            dict={}
            def get_pdf_size(pdf_file_path):
                try:
                    # Get the size of the file in bytes
                    size_bytes = os.path.getsize(pdf_file_path)

                    # Convert the size to kilobytes (1 KB = 1024 bytes)
                    size_kb = size_bytes / 1024

                    return size_bytes, size_kb
                except FileNotFoundError:
                    return None
            def get_pdf_metadata_size(pdf_file_path):
                try:
                    text = extract_text(pdf_file_path)
                    metadata_size = len(text)
                    return metadata_size
                except PDFSyntaxError as e:
                    print(f"Error reading PDF: {e}")
                    return None
            def get_pdf_page_count(pdf_file_path):
                try:
                    text = extract_text(pdf_file_path)
                    # Count the occurrences of the page delimiter
                    page_count = text.count('\f') + 1
                    return page_count
                except PDFSyntaxError as e:
                    print(-1)
                    return None
            def check_pdf_xref(pdf_file_path):
                # Extract text from the PDF
                text = extract_text(pdf_file_path)

                # Find the number of Xref entries in the extracted text
                xref_count = text.count('/XRef')

                # Print the Xref table information
                dict['xref Length']=xref_count
                dict['xref']=xref_count

            def get_pdf_title(pdf_file_path):
                # Open the PDF file and get the document metadata
                with open(pdf_file_path, 'rb') as pdf_file:
                    parser = PDFParser(pdf_file)
                    document = PDFDocument(parser)

                    # Extract title from metadata list
                    title = "0"#no title
                    for item in document.info:
                        if isinstance(item, tuple) and len(item) == 2 and item[0] == "/Title":
                            title = item[1]
                            break

                    # Print the title
                    dict['title characters']=title
            def check_pdf_encryption(pdf_file_path):
                try:
                    # Attempt to extract text from the PDF
                    text = extract_text(pdf_file_path)
                    #pdf not encrypted
                    dict['isEncrypted']=0

                except PDFSyntaxError as e:
                    if 'encrypted' in str(e):
                        dict['isEncrypted']=1
                        dict['encrpyt']=1
                    else:
                        #pdf error occured
                        dict['isEncrypted']=-1
                        dict['encrpyt']=-1
            def list_embedded_files(pdf_file_path):
                # Open the PDF file
                pdf_document = fitz.open(pdf_file_path)

                # Flag to check if any embedded files are found
                found_files = False

                # Iterate through each page
                for page_number in range(pdf_document.page_count):
                    page = pdf_document[page_number]

                    # Get the page's XObject dictionary (graphics objects)
                    xobjects = page.get_images(full=True)

                    # Iterate through the XObjects to find embedded files
                    for xobject_index, xobject_info in enumerate(xobjects):
                        # Check if the XObject has an embedded file
                        xobject_index += 1  # Adding 1 to start the index from 1
                        if "imagemask" in xobject_info and "image" in xobject_info:
                            # Print information about the embedded file
                            dict['Embedded File']=xobject_info['title']
                            found_files = True

                # Close the PDF file
                pdf_document.close()

                # Print a message if no embedded files are found
                if not found_files:
                   # print("No embedded files found in the PDF.")
                     dict['embedded files']=0

            def count_images_in_pdf(pdf_file_path):
                # Open the PDF file
                pdf_document = fitz.open(pdf_file_path)

                # Variable to store the total number of images in the PDF
                total_images = 0

                # Iterate through each page
                for page_number in range(pdf_document.page_count):
                    page = pdf_document[page_number]

                    # Get the page's XObject dictionary (graphics objects)
                    xobjects = page.get_images(full=True)

                    # Increment the total_images count for each image found on the page
                    total_images += len(xobjects)

                # Close the PDF file
                pdf_document.close()

                # Print the total number of images in the PDF or a message if no images are found
                if total_images > 0:
                    #print(f'Total number of images in the PDF: {total_images}')
                    dict['images']=total_images
                else:
                    #print('No images found in the PDF.')
                    dict['images']=0
            def is_text_present(pdf_file_path):
                try:
                    # Initialize dictionary
                    result_dict = {'text': ''}

                    # Open the PDF file
                    pdf_document = fitz.open(pdf_file_path)

                    # Iterate through pages
                    for page_number in range(pdf_document.page_count):
                        # Get the page
                        page = pdf_document[page_number]

                        # Extract text from the page
                        text = page.get_text()

                        # Check if text is present
                        if text.strip():
                            # print("1")  # yes
                            dict['text'] = '1'  # Set 'text' to '1' if text is present
                            return True

                    # No text found in the PDF
                    # print("0")  # no
                    dict['text'] = '0'
                    return False

                except Exception as e:
                    # An error occurred
                    print(f"An error occurred: {e}")
                    dict['text'] = '-2'  # Set 'text' to '-2' for unclear
                    return False

            def get_pdf_version(pdf_file_path):
                try:
                    with open(pdf_file_path, "rb") as file:
                        # Read the first few bytes of the file
                        header = file.read(8)  # Read enough bytes to include the version information

                        # Use a regular expression to extract the PDF header and version
                        match = re.match(rb"%PDF-(\d\.\d)", header)

                        if match:
                            pdf_version = match.group(1).decode("utf-8")
                            dict['header']=pdf_version
                            #print(f"%PDF-{pdf_version}")

                            return pdf_version
                        else:
                            dict['header']=-1
                            return None
                except Exception as e:
                    dict['header']=-1
                    return None
            def count_objects(pdf_file_path):
                try:
                    with open(pdf_file_path, "rb") as file:
                        pdf_content = file.read()

                        # Find occurrences of "obj"
                        obj_positions = [match.start() for match in re.finditer(rb'\bobj\b', pdf_content)]

                        # Count the total number of objects
                        obj_count = len(obj_positions)

                        # Print the number of "obj" occurrences and the total number of objects
                        #print(obj_count)
                        dict['obj']=obj_count
                        #print(obj_count)#endobj

                except Exception as e:
                    dict['obj']=-1

            def count_endobjs(pdf_file_path):
                try:
                    with open(pdf_file_path, "rb") as file:
                        pdf_content = file.read()

                        # Count occurrences of "endobj"
                        endobj_count = len(re.findall(rb'\bendobj\b', pdf_content))

                        # Print the number of "endobj" occurrences
                        dict['endobj']=endobj_count
                        #print(endobj_count)

                except Exception as e:
                    dict['endobj']=-1
            def count_streams(pdf_file_path):
                try:
                    with open(pdf_file_path, "rb") as file:
                        # Read the entire content of the PDF file
                        pdf_content = file.read()

                        # Count occurrences of "stream"
                        stream_count = pdf_content.count(b'stream')
                        endstream_count = pdf_content.count(b'endstream')

                        # Print the number of "stream" occurrences
                        dict['stream']=stream_count
                        dict['endstream']=endstream_count

                        #print(stream_count)

                except Exception as e:
                    dict['stream']=-1
                    dict['endstream']=-1
            def count_trailers(pdf_file_path):
                try:
                    # Open the PDF file in binary mode
                    with open(pdf_file_path, "rb") as file:
                        # Create a PDF reader object
                        pdf_reader = PyPDF2.PdfReader(file)

                        # Get the number of trailers (revisions)
                        trailer_count = len(pdf_reader.trailer)

                        # Print the number of trailers
                        dict['trailer']=trailer_count

                except Exception as e:
                    dict['trailer']=-1

            def count_startxref(pdf_file_path):
                try:
                    # Open the PDF file in binary mode
                    with open(pdf_file_path, "rb") as file:
                        # Create a PDF reader object
                        pdf_reader = PyPDF2.PdfReader(file)

                        # Read the content of the PDF file
                        pdf_content = file.read()

                        # Count occurrences of "startxref"
                        startxref_count = pdf_content.count(b'startxref')

                        # Print the number of "startxref" occurrences
                        dict['startxref']=startxref_count


                except Exception as e:
                    dict['startxref']=-1 
            def get_pdf_page_count(pdf_file_path):
                try:
                    text = extract_text(pdf_file_path)
                    # Count the occurrences of the page delimiter
                    page_count = text.count('\f') + 1
                    return page_count
                except PDFSyntaxError as e:
                    dict['pageno']=-1
                    return None
            
            def count_js_keywords(pdf_file_path):
                try:
                    # Open the PDF file
                    pdf_document = fitz.open(pdf_file_path)

                    # Initialize counters for "/JS" and "/JavaScript" keywords
                    js_count = 0
                    javascript_count = 0

                    # Iterate through pages
                    for page_number in range(pdf_document.page_count):
                        # Get the page
                        page = pdf_document[page_number]

                        # Search for "/JS" and "/JavaScript" in the text
                        text = page.get_text()
                        js_count += text.lower().count('/js')
                        javascript_count += text.lower().count('/javascript')

                    # Print the counts
                    dict['JS']=js_count
                    dict['javascript']=javascript_count

                except Exception as e:
                    dict['JS']=-1
                    dict['javascript']=-1
            def count_aa_openaction_keywords(pdf_file_path):
                try:
                    # Open the PDF file
                    pdf_document = fitz.open(pdf_file_path)

                    # Initialize counters for "/AA" and "/OpenAction" keywords
                    aa_count = 0
                    openaction_count = 0

                    # Iterate through pages
                    for page_number in range(pdf_document.page_count):
                        # Get the page
                        page = pdf_document[page_number]

                        # Search for "/AA" and "/OpenAction" in the text
                        text = page.get_text()
                        aa_count += text.lower().count('/aa')
                        openaction_count += text.lower().count('/openaction')

                    # Print the counts
                    dict['AA']=aa_count
                    dict['OpenAction']=openaction_count

                except Exception as e:
                    -1
                    dict['AA']=-1
                    dict['OpenAction']=-1

            def count_acroform_xfa_keywords(pdf_file_path):
                try:
                    # Open the PDF file
                    pdf_document = fitz.open(pdf_file_path)

                    # Initialize counters for "/AcroForm" and "/XFA" keywords
                    acroform_count = 0
                    xfa_count = 0

                    # Iterate through pages
                    for page_number in range(pdf_document.page_count):
                        # Get the page
                        page = pdf_document[page_number]

                        # Search for "/AcroForm" and "/XFA" in the text
                        text = page.get_text()
                        acroform_count += text.lower().count('/acroform')
                        xfa_count += text.lower().count('/xfa')

                    # Print the counts
                    dict['Acroform']=acroform_count
                    dict['XFA']=xfa_count
                   # print(f'Number of "/XFA" occurrences: {xfa_count}')

                except Exception as e:
                    dict['Acroform']=-1
            def count_jbig2decode_colors_keywords(pdf_file_path):
                try:
                    # Open the PDF file
                    pdf_document = fitz.open(pdf_file_path)

                    # Initialize counters for "/JBIG2Decode" and "/Colors" keywords
                    jbig2decode_count = 0
                    colors_count = 0

                    # Iterate through pages
                    for page_number in range(pdf_document.page_count):
                        # Get the page
                        page = pdf_document[page_number]

                        # Search for "/JBIG2Decode" and "/Colors" in the text
                        text = page.get_text()
                        jbig2decode_count += text.lower().count('/jbig2decode')
                        colors_count += text.lower().count('/colors')

                    # Print the counts
                    dict['JBIG2Decode']=0

                    #print(f'Number of "/Colors" occurrences: {colors_count}')

                except Exception as e:
                    dict['JBIG2Decode']=-1
            def count_richmedia_trailer_keywords(pdf_file_path):
                try:
                    # Open the PDF file
                    pdf_document = fitz.open(pdf_file_path)

                    # Initialize counters for "/RichMedia" and "/Trailer" keywords
                    richmedia_count = 0
                    trailer_count = 0

                    # Iterate through pages
                    for page_number in range(pdf_document.page_count):
                        # Get the page
                        page = pdf_document[page_number]

                        # Search for "/RichMedia" and "/Trailer" in the text
                        text = page.get_text()
                        richmedia_count += text.lower().count('/richmedia')
                        trailer_count += text.lower().count('/trailer')

                    # Print the counts
                    dict['RichMedia']=richmedia_count
                    #print(f'Number of "/Trailer" occurrences: {trailer_count}')

                except Exception as e:
                    dict['RichMedia']=-1
            def count_uri_action_keywords(pdf_file_path):
                try:
                    # Open the PDF file
                    pdf_document = fitz.open(pdf_file_path)

                    # Initialize counters for "/URI" and "/Action" keywords
                    uri_count = 0
                    action_count = 0

                    # Iterate through pages
                    for page_number in range(pdf_document.page_count):
                        # Get the page
                        page = pdf_document[page_number]

                        # Search for "/URI" and "/Action" in the text
                        text = page.get_text()
                        uri_count += text.lower().count('/uri')
                        action_count += text.lower().count('/action')

                    # Print the counts
                    dict['launch']=uri_count
                    #print(f'Number of "/Action" occurrences: {action_count}')

                except Exception as e:
                    dict['launch']=-1


            def count_jbig2decode_colors_keywords(pdf_file_path):
                try:
                    # Open the PDF file
                    pdf_document = fitz.open(pdf_file_path)

                    # Initialize counters for "/JBIG2Decode" and "/Colors" keywords
                    jbig2decode_count = 0
                    colors_count = 0

                    # Iterate through pages
                    for page_number in range(pdf_document.page_count):
                        # Get the page
                        page = pdf_document[page_number]

                        # Search for "/JBIG2Decode" and "/Colors" in the text
                        text = page.get_text()
                        jbig2decode_count += text.lower().count('/jbig2decode')
                        colors_count += text.lower().count('/colors')

                    # Print the counts
                   # print(f'Number of "/JBIG2Decode" occurrences: {jbig2decode_count}')
                    dict['Colors']=colors_count

                except Exception as e:
                    dict['Colors']=-1


            import fitz

            def get_embedded_files_size(pdf_file_path):
                total_size = 0
                try:
                    document = fitz.open(pdf_file_path)
                    for page_number in range(document.page_count):
                        page = document[page_number]
                        annots = page.getannots()
                        if annots:
                            for annot in annots:
                                if annot.subtype == 3:  # 3 corresponds to FileAttachment annotation type
                                    file_spec = annot.file_spec
                                    if file_spec:
                                        total_size += file_spec.file_size
                except Exception as e:
                    print(f"Error: {e}")
                finally:
                    if document:
                        document.close()
                return total_size


            import fitz  # PyMuPDF

            def count_jbig2decode_colors_keywords(pdf_path):
                try:
                    # Open the PDF file
                    pdf_document = fitz.open(pdf_path)

                    # Initialize counters for "/JBIG2Decode" and "/Colors" keywords
                    jbig2decode_count = 0
                    colors_count = 0

                    # Iterate through pages
                    for page_number in range(pdf_document.page_count):
                        # Get the page
                        page = pdf_document[page_number]

                        # Search for "/JBIG2Decode" and "/Colors" in the text
                        text = page.get_text()
                        jbig2decode_count += text.lower().count('/jbig2decode')
                        colors_count += text.lower().count('/colors')

                    # Print the counts
                    dict['JBIG2Decode']=jbig2decode_count
                    #print(f'Number of "/Colors" occurrences: {colors_count}')

                except Exception as e:
                    dict['JBIG2Decode']=-1

            # Example usage with the provided PDF file path



            # Example usage
            # pdf_file_path = r"C:\Users\iamve\Downloads\ade lab values[1].pdf"
            #pdf_file_path = r"C:\Users\iamve\Downloads\COA-Unit_1-part_3_1696500969123.pdf"
            # pdf_file_path = fr"C:\Users\iamve\Downloads\4.Fet_Amplifier_1696490256542.pdf"
            size_bytes, size_kb = get_pdf_size(pdf_file_path)

            if size_bytes is not None:
                dict['pdfsize']=size_bytes

            else:
                dict['pdfsize']=0



            metadata_size = get_pdf_metadata_size(pdf_file_path)
            if metadata_size is not None:
                dict['metadata size']=metadata_size



            page_count = get_pdf_page_count(pdf_file_path)
            if page_count is not None:
                dict['pages']=page_count-1 


            check_pdf_xref(pdf_file_path)
            get_pdf_title(pdf_file_path)
            check_pdf_encryption(pdf_file_path)
            list_embedded_files(pdf_file_path)
            count_images_in_pdf(pdf_file_path)
            is_text_present(pdf_file_path)
            pdf_version = get_pdf_version(pdf_file_path)
            count_objects(pdf_file_path)
            count_endobjs(pdf_file_path)
            count_streams(pdf_file_path)
            count_trailers(pdf_file_path)
            count_startxref(pdf_file_path)
            page_count = get_pdf_page_count(pdf_file_path)
            if page_count is not None:
                dict['pageno']=page_count-1
            # objstm_count = get_number_of_objstm(pdf_file_path)
            # dict['ObjStm']=objstm_count
            count_js_keywords(pdf_file_path)
            count_aa_openaction_keywords(pdf_file_path)
            count_acroform_xfa_keywords(pdf_file_path)
            count_jbig2decode_colors_keywords(pdf_file_path)
            count_richmedia_trailer_keywords(pdf_file_path)
            count_uri_action_keywords(pdf_file_path)#launch
            count_jbig2decode_colors_keywords(pdf_file_path)
            average_size = get_embedded_files_size(pdf_file_path)
            dict['EmbeddedFile']=average_size

            new_features_dict=dict

            # Load the trained RandomForestClassifier model
            trained_model = joblib.load('random_forest_model.joblib')

            # Reshape the feature values
            new_feature_values = [
            new_features_dict['pdfsize'],
            new_features_dict['metadata size'],
            new_features_dict['pages'],
            new_features_dict['xref Length'],
            new_features_dict['xref'],
            new_features_dict['title characters'],
            new_features_dict['isEncrypted'],
            new_features_dict['embedded files'],
            new_features_dict['images'],
            new_features_dict['text'],
            new_features_dict['header'],
            new_features_dict['obj'],
            new_features_dict['endobj'],
            new_features_dict['stream'],
            new_features_dict['endstream'],
            new_features_dict['trailer'],
            new_features_dict['startxref'],
            new_features_dict['pageno'],
            new_features_dict['JS'],
            new_features_dict['javascript'],
            new_features_dict['AA'],
            new_features_dict['OpenAction'],
            new_features_dict['Acroform'],
            new_features_dict['XFA'],
            new_features_dict['JBIG2Decode'],
            new_features_dict['RichMedia'],
            new_features_dict['launch'],
            new_features_dict['EmbeddedFile'],


            ]
            new_feature_values_reshaped = [new_feature_values]

            # Use the trained model to predict the output for the new features
            predicted_output = trained_model.predict(new_feature_values_reshaped)

            # Return the predicted output
            return "Malicious" if predicted_output[0] == -1 else "Benign"

        except Exception as e:
            return "Error: " + str(e)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = PDFClassifierApp()
    sys.exit(app.exec_())
